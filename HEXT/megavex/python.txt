{
    "OBJ scripts": {
        "Create Render Subnet": {
            "python_code": [
                "import lzRS_Shelf\nlzRS_Shelf.createShotSubnet()\n\n\n\n\n"
            ]
        }
    },
    "Snippets": {
        "ABC split paths": {
            "python_code": [
                "import toolutils, nodegraphalign\neditor = toolutils.networkEditor()\nn = hou.pwd()\ng = n.inputs()[0].geometry()\npath_att = g.findPrimAttrib(\"path\")\n\ndef getNodeOutputNames(n):\n    return [ x.name() for x in n.outputs()]\n\ndef getOutputByName(n,name):\n    for out in n.outputs():\n        if out.name() == name:\n            return out\n    return None\n\n# Create blast tree\nout_nulls = []\nfor str in path_att.strings():\n    _node = n\n    _path = \"\"\n    for str_part in str.split(\"/\"):\n        _path += str_part + \"/\"\n        if str_part:\n            if str_part in getNodeOutputNames(_node):\n                _node = getOutputByName(_node,str_part)\n            else:\n                _node = _node.createOutputNode(\"blast\",str_part)\n                _node.setParms({\"group\":f\"@path={_path}*\",\"grouptype\":4,\"negate\":1})\n                \n    out_null = _node.createOutputNode(\"null\",str.replace(\"/\",\"__\"))\n    out_nulls.append(out_null)\n            \n# align our nodes         \nnodegraphalign.alignConnected(editor,n,None,\"down\")\n\n# Find min y pos for out_nulls\nmin_y = None\nfor out in out_nulls:\n    if min_y == None : \n        min_y = out.position()[1] \n    else:\n        min_y = min(min_y, out.position()[1])\n\n# create obj Merges\ni = 0    \nfor out in out_nulls:    \n    out.setPosition(hou.Vector2( out.position()[0],min_y - 2.0))\n    #create merge\n    merge_node = hou.node(\"/obj\").createNode(\"geo\",out.name())\n    merge = merge_node.createNode(\"object_merge\",out.name())\n    merge.parm(\"objpath1\").set(out.path()) \n    # move to good position\n    merge_node.setPosition( out.parent().position() + hou.Vector2( 4 , i*-0.5  ) )\n    i += 1\n    \n    \n    \n    \n\n"
            ]
        },
        "Download scene from FTP": {
            "python_code": [
                "import lzutil\nfile = \"Z:/OUTSOURCE_2021/BookWalker/Shots/sh100/lighting/sh100_Final_a.hip\"\nlzutil.ftp_downloadFromCanoeServer(file)\nhou.hipFile.load(file)\n"
            ]
        },
        "FTP scripts": {
            "python_code": [
                "# Download HIP\nimport lzutil\nfile = \"Z:/OUTSOURCE_2021/BookWalker/Shots/sh100/lighting/sh100_Final_a.hip\"\nlzutil.ftp_downloadFromCanoeServer(file)\nhou.hipFile.load(file)\n",
                "# Upload HIP\nimport lzutil\nlzutil.ftp_downloadFromCanoeServer(hou.hipFile.path(), upload=True)"
            ]
        },
        "RS Display Only ProxiesOnDisk Expression": {
            "python_code": [
                "# Display only proxies on disk expression\nfor n in hou.node(\"/obj\").children():\n    p = n.parm(\"RS_objprop_proxy_enable\")\n    if not p: continue\n    if p.eval():\n        n.parm(\"tdisplay\").set(1)\n        n.parm('display').setExpression('import os;\\nreturn os.path.isfile(hou.pwd().parm(\"RS_objprop_proxy_file\").eval()) if hou.pwd().parm(\"RS_objprop_proxy_enable\").eval() else 1',language = hou.exprLanguage.Python)    \n        print(\"Updated\", n.name())\n        \n\n    \n    \n\n\n"
            ]
        }
    }
}