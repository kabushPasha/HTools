{
    "OBJ scripts": {
        "Create Render Subnet": {
            "python_code": [
                "import lzRS_Shelf\nlzRS_Shelf.createShotSubnet()\n\n\n\n\n"
            ]
        }
    },
    "Snippets": {
        "ABC split paths": {
            "python_code": [
                "import toolutils, nodegraphalign\neditor = toolutils.networkEditor()\nn = hou.pwd()\ng = n.inputs()[0].geometry()\npath_att = g.findPrimAttrib(\"path\")\n\ndef getNodeOutputNames(n):\n    return [ x.name() for x in n.outputs()]\n\ndef getOutputByName(n,name):\n    for out in n.outputs():\n        if out.name() == name:\n            return out\n    return None\n\n# Create blast tree\nout_nulls = []\nfor str in path_att.strings():\n    _node = n\n    _path = \"\"\n    for str_part in str.split(\"/\"):\n        _path += str_part + \"/\"\n        if str_part:\n            if str_part in getNodeOutputNames(_node):\n                _node = getOutputByName(_node,str_part)\n            else:\n                _node = _node.createOutputNode(\"blast\",str_part)\n                _node.setParms({\"group\":f\"@path={_path}*\",\"grouptype\":4,\"negate\":1})\n                \n    out_null = _node.createOutputNode(\"null\",str.replace(\"/\",\"__\"))\n    out_nulls.append(out_null)\n            \n# align our nodes         \nnodegraphalign.alignConnected(editor,n,None,\"down\")\n\n# Find min y pos for out_nulls\nmin_y = None\nfor out in out_nulls:\n    if min_y == None : \n        min_y = out.position()[1] \n    else:\n        min_y = min(min_y, out.position()[1])\n\n# create obj Merges\ni = 0    \nfor out in out_nulls:    \n    out.setPosition(hou.Vector2( out.position()[0],min_y - 2.0))\n    #create merge\n    merge_node = hou.node(\"/obj\").createNode(\"geo\",out.name())\n    merge = merge_node.createNode(\"object_merge\",out.name())\n    merge.parm(\"objpath1\").set(out.path()) \n    # move to good position\n    merge_node.setPosition( out.parent().position() + hou.Vector2( 4 , i*-0.5  ) )\n    i += 1\n    \n    \n    \n    \n\n"
            ]
        },
        "Calc BB": {
            "python_code": [
                "# Get BBox of full frange\nn = hou.pwd().inputs()[0]\nbb = hou.BoundingBox()\n\nfstart = int(hou.expandString(\"1\"))\nfend = int(hou.expandString(\"360\"))\n\nfor i in range(fstart , fend + 1):\n    g = n.geometryAtFrame(i)\n    bb.enlargeToContain(g.boundingBox())\n    \n    \nbox = hou.pwd().createOutputNode(\"box\",\"bb\")\nbox.parmTuple(\"t\").set(bb.center())\nbox.parmTuple(\"size\").set(bb.sizevec())\n\n\n"
            ]
        },
        "FTP scripts": {
            "python_code": [
                "# Upload HIP\nimport lzutil\nlzutil.ftp_downloadFromCanoeServer(hou.hipFile.path(), upload=True)",
                "# Download Scene From FTP\nimport lzutil\nfile = hou.pwd().parm(\"file\").eval() #defparm file \"\"\nupload = hou.pwd().parm(\"upload\").eval() #defparm toggle 0\nlzutil.ftp_downloadFromCanoeServer(file,upload)\n\n\nload_scene = hou.pwd().parm(\"load_hipfile\").eval() #defparm toggle 0\nif load_scene:\n    hou.hipFile.load(file)\n"
            ]
        },
        "Import Materials From FBX": {
            "python_code": [
                "# Import Materials From FBX\nimport os,glob\nfile_node = hou.pwd().inputs()[0]\nfile_path = file_node.parm(\"file\").eval()\ntex_searchFolder = hou.pwd().parm(\"tex_searchFolder\").eval() #defparm file \n\nfbx = hou.hipFile.importFBX( file_name = file_path ,\n    import_cameras = 0,\n    import_joints_and_skin = 0,\n    import_lights = 0,\n    import_animation = 0)[0]\n\n\nmat_types = []\nmat_ptypes = []    \n\nmat_convert_dict = {\n\"basecolor\" : \"diffuse_color\",\n\"rough\" : \"refl_roughness\",\n\"basecolor_useTexture\":\"tex_diffuse_color\",\n\"reflect\" : \"refl_weight\",\n\"emitcolor\" : \"emission_color\",\n'basecolor_texture' : \"lztex_basecolor\",\n'rough_useTexture': \"tex_refl_roughness\",\n'rough_texture' : \"lztex_roughness\", \n'emitcolor_useTexture' : \"tex_emission_color\", \n'emitcolor_texture' : \"lztex_emission\",\n'baseBumpAndNormal_enable' : \"tex_bump_input\", \n'baseNormal_texture':\"lztex_normal\"\n}\n\nmat = hou.pwd()\nfor node in fbx.children():\n    if node.type().name() == \"geo\":\n        name = node.name()\n        mat_path = node.parm(\"shop_materialpath\").eval()\n        \n        if mat_path == \"\": continue\n        \n        src_mat = hou.node(mat_path)   \n                \n        mat = mat.createOutputNode(\"Rs_quickMat::009\",name)\n        mat.parm('basegroup').set(f\"@name={name}\")\n        mat.parm(\"use_simple_mat\").set(1)\n        hou.setPwd(mat)\n        mat.hm().Link()\n        \n        for p in src_mat.parmTuples():\n            if not p.isAtDefault():\n                pname = p.name()   \n                pt_type = p.parmTemplate().type().name()\n                \n                if pt_type == \"FolderSet\" : continue  \n                \n                if pname in mat_convert_dict.keys():\n                    mat_p = mat.parmTuple(mat_convert_dict[pname])\n                    mat_p.deleteAllKeyframes()\n                    mat_p.set(p.eval())\n                    \n                    # Run callback script\n                    if \"script_callback\" in  mat_p.parmTemplate().tags():\n                        kwargs['parm_name'] = mat_convert_dict[pname]\n                        kwargs['script_value'] = \"on\"\n                        exec( mat_p.parmTemplate().tags()[\"script_callback\"] )\n                        \n                        \n                    # Try To Find Texture \n                    if pt_type == \"String\":\n                        base_path = p.eval()[0]\n                        local_tex = os.path.isfile(base_path)\n                        if not local_tex:\n                            tex_name = os.path.basename( base_path )                  \n                            glob_tex =  glob.glob(tex_searchFolder + \"/**/\" + tex_name + \"*\" ,recursive=True)\n                            if glob_tex:\n                                mat_p.set([glob_tex[0]])\n                            else:\n                                print(\"MissingTexture: \" + base_path )\n                                \n                        \n                \n                    continue\n                \n                if pname not in mat_types: mat_types.append(pname)\n                if pt_type not in mat_ptypes: mat_ptypes.append(pt_type)               \n                \n                \n\nprint(mat_types)\nprint(mat_ptypes)\n    \nfbx.destroy()\n\n\n\n",
                "#Fix texture paths\n\nold_path = hou.pwd().parm(\"old_path\").eval() #defparm file \"\"\nnew_path = hou.pwd().parm(\"new_path\").eval() #defparm file \"\"\n\ncommand = f\"opchange {old_path} {new_path}\"\nhou.hscript(command)",
                "# Quickmats based on Mats\n\ng = hou.pwd().inputs()[0].geometry()\nmat = hou.pwd()\n\nmaterials = g.findPrimAttrib(\"shop_materialpath\").strings()\n\nfor i in range(0,len(materials)):\n    str = materials[i]                    \n\n    mat = mat.createOutputNode(\"Rs_quickMat\",str)\n    mat.parm('basegroup').set(f\"@shop_materialpath={str}\")\n    \n    c = hou.Color()\n    hue =  i * 360 / len(materials)\n    c.setHSV( (hue , 0.75, 0.75) )\n    \n    mat.setColor(c)\n    dif = mat.parmTuple(\"mat/mat/ogl_diff\")\n    dif.deleteAllKeyframes()\n    dif.set(c.rgb())\n    \n    \n    ",
                "# Create Multimat Network\n# Currentlynot working, just some tets\n\ng = hou.pwd().inputs()[0].geometry()\nmat = []\n\nmaterials = g.findPrimAttrib(\"shop_materialpath\").strings()\n\nmatnet = hou.node(\"/mat\")\n\n\nfor i in range(0,len(materials)):\n    str = materials[i]                    \n\n    new_mat = matnet.createNode(\"redshift_material\",str)\n    \n    \n    if mat:\n        new_mat.setPosition(mat.position() + hou.Vector2(0,2))\n    mat = new_mat\n    \n    #mat.createInputNode(0,\"null\")\n    \n    \n"
            ]
        },
        "RS Display Only ProxiesOnDisk Expression": {
            "python_code": [
                "# Display only proxies on disk expression\nfor n in hou.node(\"/obj\").children():\n    p = n.parm(\"RS_objprop_proxy_enable\")\n    if not p: continue\n    if p.eval():\n        n.parm(\"tdisplay\").set(1)\n        n.parm('display').setExpression('import os;\\nreturn os.path.isfile(hou.pwd().parm(\"RS_objprop_proxy_file\").eval()) if hou.pwd().parm(\"RS_objprop_proxy_enable\").eval() else 1',language = hou.exprLanguage.Python)    \n        print(\"Updated\", n.name())\n        \n\n    \n    \n\n\n"
            ]
        }
    }
}